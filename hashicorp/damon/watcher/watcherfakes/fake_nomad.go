// Code generated by counterfeiter. DO NOT EDIT.
package watcherfakes

import (
	"sync"

	"github.com/hashicorp/nomad/api"
	"github.com/hcjulz/damon/models"
	"github.com/hcjulz/damon/nomad"
	"github.com/hcjulz/damon/watcher"
)

type FakeNomad struct {
	AddressStub        func() string
	addressMutex       sync.RWMutex
	addressArgsForCall []struct {
	}
	addressReturns struct {
		result1 string
	}
	addressReturnsOnCall map[int]struct {
		result1 string
	}
	AllocationsStub        func(*nomad.SearchOptions) ([]*models.Alloc, error)
	allocationsMutex       sync.RWMutex
	allocationsArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	allocationsReturns struct {
		result1 []*models.Alloc
		result2 error
	}
	allocationsReturnsOnCall map[int]struct {
		result1 []*models.Alloc
		result2 error
	}
	DeploymentsStub        func(*nomad.SearchOptions) ([]*models.Deployment, error)
	deploymentsMutex       sync.RWMutex
	deploymentsArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	deploymentsReturns struct {
		result1 []*models.Deployment
		result2 error
	}
	deploymentsReturnsOnCall map[int]struct {
		result1 []*models.Deployment
		result2 error
	}
	JobAllocsStub        func(string, *nomad.SearchOptions) ([]*models.Alloc, error)
	jobAllocsMutex       sync.RWMutex
	jobAllocsArgsForCall []struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}
	jobAllocsReturns struct {
		result1 []*models.Alloc
		result2 error
	}
	jobAllocsReturnsOnCall map[int]struct {
		result1 []*models.Alloc
		result2 error
	}
	JobsStub        func(*nomad.SearchOptions) ([]*models.Job, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	jobsReturns struct {
		result1 []*models.Job
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 []*models.Job
		result2 error
	}
	LogsStub        func(string, string, string, <-chan struct{}) (<-chan *api.StreamFrame, <-chan error)
	logsMutex       sync.RWMutex
	logsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 <-chan struct{}
	}
	logsReturns struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}
	logsReturnsOnCall map[int]struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}
	NamespacesStub        func(*nomad.SearchOptions) ([]*models.Namespace, error)
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	namespacesReturns struct {
		result1 []*models.Namespace
		result2 error
	}
	namespacesReturnsOnCall map[int]struct {
		result1 []*models.Namespace
		result2 error
	}
	JobStatusStub        func(string, *nomad.SearchOptions) (*models.JobStatus, error)
	jobstatusMutex       sync.RWMutex
	jobstatusArgsForCall []struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}
	jobstatusReturns struct {
		result1 *models.JobStatus
		result2 error
	}
	jobstatusReturnsOnCall map[int]struct {
		result1 *models.JobStatus
		result2 error
	}
	StreamStub        func(nomad.Topics, uint64) (<-chan *api.Events, error)
	streamMutex       sync.RWMutex
	streamArgsForCall []struct {
		arg1 nomad.Topics
		arg2 uint64
	}
	streamReturns struct {
		result1 <-chan *api.Events
		result2 error
	}
	streamReturnsOnCall map[int]struct {
		result1 <-chan *api.Events
		result2 error
	}
	TaskGroupsStub        func(string, *nomad.SearchOptions) ([]*models.TaskGroup, error)
	taskGroupsMutex       sync.RWMutex
	taskGroupsArgsForCall []struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}
	taskGroupsReturns struct {
		result1 []*models.TaskGroup
		result2 error
	}
	taskGroupsReturnsOnCall map[int]struct {
		result1 []*models.TaskGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNomad) Address() string {
	fake.addressMutex.Lock()
	ret, specificReturn := fake.addressReturnsOnCall[len(fake.addressArgsForCall)]
	fake.addressArgsForCall = append(fake.addressArgsForCall, struct {
	}{})
	stub := fake.AddressStub
	fakeReturns := fake.addressReturns
	fake.recordInvocation("Address", []interface{}{})
	fake.addressMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNomad) AddressCallCount() int {
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	return len(fake.addressArgsForCall)
}

func (fake *FakeNomad) AddressCalls(stub func() string) {
	fake.addressMutex.Lock()
	defer fake.addressMutex.Unlock()
	fake.AddressStub = stub
}

func (fake *FakeNomad) AddressReturns(result1 string) {
	fake.addressMutex.Lock()
	defer fake.addressMutex.Unlock()
	fake.AddressStub = nil
	fake.addressReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeNomad) AddressReturnsOnCall(i int, result1 string) {
	fake.addressMutex.Lock()
	defer fake.addressMutex.Unlock()
	fake.AddressStub = nil
	if fake.addressReturnsOnCall == nil {
		fake.addressReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.addressReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeNomad) Allocations(arg1 *nomad.SearchOptions) ([]*models.Alloc, error) {
	fake.allocationsMutex.Lock()
	ret, specificReturn := fake.allocationsReturnsOnCall[len(fake.allocationsArgsForCall)]
	fake.allocationsArgsForCall = append(fake.allocationsArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.AllocationsStub
	fakeReturns := fake.allocationsReturns
	fake.recordInvocation("Allocations", []interface{}{arg1})
	fake.allocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) AllocationsCallCount() int {
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	return len(fake.allocationsArgsForCall)
}

func (fake *FakeNomad) AllocationsCalls(stub func(*nomad.SearchOptions) ([]*models.Alloc, error)) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = stub
}

func (fake *FakeNomad) AllocationsArgsForCall(i int) *nomad.SearchOptions {
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	argsForCall := fake.allocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) AllocationsReturns(result1 []*models.Alloc, result2 error) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = nil
	fake.allocationsReturns = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) AllocationsReturnsOnCall(i int, result1 []*models.Alloc, result2 error) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = nil
	if fake.allocationsReturnsOnCall == nil {
		fake.allocationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Alloc
			result2 error
		})
	}
	fake.allocationsReturnsOnCall[i] = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Deployments(arg1 *nomad.SearchOptions) ([]*models.Deployment, error) {
	fake.deploymentsMutex.Lock()
	ret, specificReturn := fake.deploymentsReturnsOnCall[len(fake.deploymentsArgsForCall)]
	fake.deploymentsArgsForCall = append(fake.deploymentsArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.DeploymentsStub
	fakeReturns := fake.deploymentsReturns
	fake.recordInvocation("Deployments", []interface{}{arg1})
	fake.deploymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) DeploymentsCallCount() int {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	return len(fake.deploymentsArgsForCall)
}

func (fake *FakeNomad) DeploymentsCalls(stub func(*nomad.SearchOptions) ([]*models.Deployment, error)) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = stub
}

func (fake *FakeNomad) DeploymentsArgsForCall(i int) *nomad.SearchOptions {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	argsForCall := fake.deploymentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) DeploymentsReturns(result1 []*models.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	fake.deploymentsReturns = struct {
		result1 []*models.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) DeploymentsReturnsOnCall(i int, result1 []*models.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	if fake.deploymentsReturnsOnCall == nil {
		fake.deploymentsReturnsOnCall = make(map[int]struct {
			result1 []*models.Deployment
			result2 error
		})
	}
	fake.deploymentsReturnsOnCall[i] = struct {
		result1 []*models.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobAllocs(arg1 string, arg2 *nomad.SearchOptions) ([]*models.Alloc, error) {
	fake.jobAllocsMutex.Lock()
	ret, specificReturn := fake.jobAllocsReturnsOnCall[len(fake.jobAllocsArgsForCall)]
	fake.jobAllocsArgsForCall = append(fake.jobAllocsArgsForCall, struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}{arg1, arg2})
	stub := fake.JobAllocsStub
	fakeReturns := fake.jobAllocsReturns
	fake.recordInvocation("JobAllocs", []interface{}{arg1, arg2})
	fake.jobAllocsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) JobAllocsCallCount() int {
	fake.jobAllocsMutex.RLock()
	defer fake.jobAllocsMutex.RUnlock()
	return len(fake.jobAllocsArgsForCall)
}

func (fake *FakeNomad) JobAllocsCalls(stub func(string, *nomad.SearchOptions) ([]*models.Alloc, error)) {
	fake.jobAllocsMutex.Lock()
	defer fake.jobAllocsMutex.Unlock()
	fake.JobAllocsStub = stub
}

func (fake *FakeNomad) JobAllocsArgsForCall(i int) (string, *nomad.SearchOptions) {
	fake.jobAllocsMutex.RLock()
	defer fake.jobAllocsMutex.RUnlock()
	argsForCall := fake.jobAllocsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNomad) JobAllocsReturns(result1 []*models.Alloc, result2 error) {
	fake.jobAllocsMutex.Lock()
	defer fake.jobAllocsMutex.Unlock()
	fake.JobAllocsStub = nil
	fake.jobAllocsReturns = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobAllocsReturnsOnCall(i int, result1 []*models.Alloc, result2 error) {
	fake.jobAllocsMutex.Lock()
	defer fake.jobAllocsMutex.Unlock()
	fake.JobAllocsStub = nil
	if fake.jobAllocsReturnsOnCall == nil {
		fake.jobAllocsReturnsOnCall = make(map[int]struct {
			result1 []*models.Alloc
			result2 error
		})
	}
	fake.jobAllocsReturnsOnCall[i] = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Jobs(arg1 *nomad.SearchOptions) ([]*models.Job, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.JobsStub
	fakeReturns := fake.jobsReturns
	fake.recordInvocation("Jobs", []interface{}{arg1})
	fake.jobsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakeNomad) JobsCalls(stub func(*nomad.SearchOptions) ([]*models.Job, error)) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = stub
}

func (fake *FakeNomad) JobsArgsForCall(i int) *nomad.SearchOptions {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	argsForCall := fake.jobsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) JobsReturns(result1 []*models.Job, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 []*models.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobsReturnsOnCall(i int, result1 []*models.Job, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 []*models.Job
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 []*models.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Logs(arg1 string, arg2 string, arg3 string, arg4 <-chan struct{}) (<-chan *api.StreamFrame, <-chan error) {
	fake.logsMutex.Lock()
	ret, specificReturn := fake.logsReturnsOnCall[len(fake.logsArgsForCall)]
	fake.logsArgsForCall = append(fake.logsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 <-chan struct{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LogsStub
	fakeReturns := fake.logsReturns
	fake.recordInvocation("Logs", []interface{}{arg1, arg2, arg3, arg4})
	fake.logsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) LogsCallCount() int {
	fake.logsMutex.RLock()
	defer fake.logsMutex.RUnlock()
	return len(fake.logsArgsForCall)
}

func (fake *FakeNomad) LogsCalls(stub func(string, string, string, <-chan struct{}) (<-chan *api.StreamFrame, <-chan error)) {
	fake.logsMutex.Lock()
	defer fake.logsMutex.Unlock()
	fake.LogsStub = stub
}

func (fake *FakeNomad) LogsArgsForCall(i int) (string, string, string, <-chan struct{}) {
	fake.logsMutex.RLock()
	defer fake.logsMutex.RUnlock()
	argsForCall := fake.logsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNomad) LogsReturns(result1 <-chan *api.StreamFrame, result2 <-chan error) {
	fake.logsMutex.Lock()
	defer fake.logsMutex.Unlock()
	fake.LogsStub = nil
	fake.logsReturns = struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeNomad) LogsReturnsOnCall(i int, result1 <-chan *api.StreamFrame, result2 <-chan error) {
	fake.logsMutex.Lock()
	defer fake.logsMutex.Unlock()
	fake.LogsStub = nil
	if fake.logsReturnsOnCall == nil {
		fake.logsReturnsOnCall = make(map[int]struct {
			result1 <-chan *api.StreamFrame
			result2 <-chan error
		})
	}
	fake.logsReturnsOnCall[i] = struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeNomad) Namespaces(arg1 *nomad.SearchOptions) ([]*models.Namespace, error) {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.NamespacesStub
	fakeReturns := fake.namespacesReturns
	fake.recordInvocation("Namespaces", []interface{}{arg1})
	fake.namespacesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeNomad) NamespacesCalls(stub func(*nomad.SearchOptions) ([]*models.Namespace, error)) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FakeNomad) NamespacesArgsForCall(i int) *nomad.SearchOptions {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	argsForCall := fake.namespacesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) NamespacesReturns(result1 []*models.Namespace, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 []*models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) NamespacesReturnsOnCall(i int, result1 []*models.Namespace, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 []*models.Namespace
			result2 error
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 []*models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobStatusCallCount() int {
	fake.jobstatusMutex.RLock()
	defer fake.jobstatusMutex.RUnlock()
	return len(fake.jobstatusArgsForCall)
}

func (fake *FakeNomad) JobStatusCalls(stub func(string, *nomad.SearchOptions) (*models.JobStatus, error)) {
	fake.jobstatusMutex.Lock()
	defer fake.jobstatusMutex.Unlock()
	fake.JobStatusStub = stub
}

func (fake *FakeNomad) JobStatusForCall(i int) *nomad.SearchOptions {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	argsForCall := fake.namespacesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) JobStatus(arg1 string, arg2 *nomad.SearchOptions) (*models.JobStatus, error) {
	fake.jobstatusMutex.Lock()
	ret, specificReturn := fake.jobstatusReturnsOnCall[len(fake.jobstatusArgsForCall)]
	fake.jobstatusArgsForCall = append(fake.jobstatusArgsForCall, struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}{arg1, arg2})
	stub := fake.JobStatusStub
	fakeReturns := fake.jobstatusReturns
	fake.recordInvocation("JobStatus", []interface{}{arg1})
	fake.jobstatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) JobStatusReturnsOnCall(i int, result1 *models.JobStatus, result2 error) {
	fake.jobstatusMutex.Lock()
	defer fake.jobstatusMutex.Unlock()
	fake.JobStatusStub = nil
	if fake.jobstatusReturnsOnCall == nil {
		fake.jobstatusReturnsOnCall = make(map[int]struct {
			result1 *models.JobStatus
			result2 error
		})
	}
	fake.jobstatusReturnsOnCall[i] = struct {
		result1 *models.JobStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobStatusReturns(result1 *models.JobStatus, result2 error) {
	fake.jobstatusMutex.Lock()
	defer fake.jobstatusMutex.Unlock()
	fake.JobStatusStub = nil
	fake.jobstatusReturns = struct {
		result1 *models.JobStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Stream(arg1 nomad.Topics, arg2 uint64) (<-chan *api.Events, error) {
	fake.streamMutex.Lock()
	ret, specificReturn := fake.streamReturnsOnCall[len(fake.streamArgsForCall)]
	fake.streamArgsForCall = append(fake.streamArgsForCall, struct {
		arg1 nomad.Topics
		arg2 uint64
	}{arg1, arg2})
	stub := fake.StreamStub
	fakeReturns := fake.streamReturns
	fake.recordInvocation("Stream", []interface{}{arg1, arg2})
	fake.streamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) StreamCallCount() int {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	return len(fake.streamArgsForCall)
}

func (fake *FakeNomad) StreamCalls(stub func(nomad.Topics, uint64) (<-chan *api.Events, error)) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = stub
}

func (fake *FakeNomad) StreamArgsForCall(i int) (nomad.Topics, uint64) {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	argsForCall := fake.streamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNomad) StreamReturns(result1 <-chan *api.Events, result2 error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = nil
	fake.streamReturns = struct {
		result1 <-chan *api.Events
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) StreamReturnsOnCall(i int, result1 <-chan *api.Events, result2 error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = nil
	if fake.streamReturnsOnCall == nil {
		fake.streamReturnsOnCall = make(map[int]struct {
			result1 <-chan *api.Events
			result2 error
		})
	}
	fake.streamReturnsOnCall[i] = struct {
		result1 <-chan *api.Events
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) TaskGroups(arg1 string, arg2 *nomad.SearchOptions) ([]*models.TaskGroup, error) {
	fake.taskGroupsMutex.Lock()
	ret, specificReturn := fake.taskGroupsReturnsOnCall[len(fake.taskGroupsArgsForCall)]
	fake.taskGroupsArgsForCall = append(fake.taskGroupsArgsForCall, struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}{arg1, arg2})
	stub := fake.TaskGroupsStub
	fakeReturns := fake.taskGroupsReturns
	fake.recordInvocation("TaskGroups", []interface{}{arg1, arg2})
	fake.taskGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) TaskGroupsCallCount() int {
	fake.taskGroupsMutex.RLock()
	defer fake.taskGroupsMutex.RUnlock()
	return len(fake.taskGroupsArgsForCall)
}

func (fake *FakeNomad) TaskGroupsCalls(stub func(string, *nomad.SearchOptions) ([]*models.TaskGroup, error)) {
	fake.taskGroupsMutex.Lock()
	defer fake.taskGroupsMutex.Unlock()
	fake.TaskGroupsStub = stub
}

func (fake *FakeNomad) TaskGroupsArgsForCall(i int) (string, *nomad.SearchOptions) {
	fake.taskGroupsMutex.RLock()
	defer fake.taskGroupsMutex.RUnlock()
	argsForCall := fake.taskGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNomad) TaskGroupsReturns(result1 []*models.TaskGroup, result2 error) {
	fake.taskGroupsMutex.Lock()
	defer fake.taskGroupsMutex.Unlock()
	fake.TaskGroupsStub = nil
	fake.taskGroupsReturns = struct {
		result1 []*models.TaskGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) TaskGroupsReturnsOnCall(i int, result1 []*models.TaskGroup, result2 error) {
	fake.taskGroupsMutex.Lock()
	defer fake.taskGroupsMutex.Unlock()
	fake.TaskGroupsStub = nil
	if fake.taskGroupsReturnsOnCall == nil {
		fake.taskGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.TaskGroup
			result2 error
		})
	}
	fake.taskGroupsReturnsOnCall[i] = struct {
		result1 []*models.TaskGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	fake.jobAllocsMutex.RLock()
	defer fake.jobAllocsMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.logsMutex.RLock()
	defer fake.logsMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	fake.taskGroupsMutex.RLock()
	defer fake.taskGroupsMutex.RUnlock()
	fake.jobstatusMutex.RLock()
	defer fake.jobstatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNomad) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ watcher.Nomad = new(FakeNomad)
