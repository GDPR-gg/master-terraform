// Code generated by counterfeiter. DO NOT EDIT.
package nomadfakes

import (
	"sync"

	"github.com/hashicorp/nomad/api"
	"github.com/hcjulz/damon/nomad"
)

type FakeJobClient struct {
	AllocationsStub        func(string, bool, *api.QueryOptions) ([]*api.AllocationListStub, *api.QueryMeta, error)
	allocationsMutex       sync.RWMutex
	allocationsArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 *api.QueryOptions
	}
	allocationsReturns struct {
		result1 []*api.AllocationListStub
		result2 *api.QueryMeta
		result3 error
	}
	allocationsReturnsOnCall map[int]struct {
		result1 []*api.AllocationListStub
		result2 *api.QueryMeta
		result3 error
	}
	DeregisterStub        func(string, bool, *api.WriteOptions) (string, *api.WriteMeta, error)
	deregisterMutex       sync.RWMutex
	deregisterArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 *api.WriteOptions
	}
	deregisterReturns struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}
	deregisterReturnsOnCall map[int]struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}
	InfoStub        func(string, *api.QueryOptions) (*api.Job, *api.QueryMeta, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 string
		arg2 *api.QueryOptions
	}
	infoReturns struct {
		result1 *api.Job
		result2 *api.QueryMeta
		result3 error
	}
	infoReturnsOnCall map[int]struct {
		result1 *api.Job
		result2 *api.QueryMeta
		result3 error
	}
	ListStub        func(*api.QueryOptions) ([]*api.JobListStub, *api.QueryMeta, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 *api.QueryOptions
	}
	listReturns struct {
		result1 []*api.JobListStub
		result2 *api.QueryMeta
		result3 error
	}
	listReturnsOnCall map[int]struct {
		result1 []*api.JobListStub
		result2 *api.QueryMeta
		result3 error
	}
	RegisterStub        func(*api.Job, *api.WriteOptions) (*api.JobRegisterResponse, *api.WriteMeta, error)
	registerMutex       sync.RWMutex
	registerArgsForCall []struct {
		arg1 *api.Job
		arg2 *api.WriteOptions
	}
	registerReturns struct {
		result1 *api.JobRegisterResponse
		result2 *api.WriteMeta
		result3 error
	}
	registerReturnsOnCall map[int]struct {
		result1 *api.JobRegisterResponse
		result2 *api.WriteMeta
		result3 error
	}
	SummaryStub        func(string, *api.QueryOptions) (*api.JobSummary, *api.QueryMeta, error)
	summaryMutex       sync.RWMutex
	summaryArgsForCall []struct {
		arg1 string
		arg2 *api.QueryOptions
	}
	summaryReturns struct {
		result1 *api.JobSummary
		result2 *api.QueryMeta
		result3 error
	}
	summaryReturnsOnCall map[int]struct {
		result1 *api.JobSummary
		result2 *api.QueryMeta
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJobClient) Allocations(arg1 string, arg2 bool, arg3 *api.QueryOptions) ([]*api.AllocationListStub, *api.QueryMeta, error) {
	fake.allocationsMutex.Lock()
	ret, specificReturn := fake.allocationsReturnsOnCall[len(fake.allocationsArgsForCall)]
	fake.allocationsArgsForCall = append(fake.allocationsArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 *api.QueryOptions
	}{arg1, arg2, arg3})
	stub := fake.AllocationsStub
	fakeReturns := fake.allocationsReturns
	fake.recordInvocation("Allocations", []interface{}{arg1, arg2, arg3})
	fake.allocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJobClient) AllocationsCallCount() int {
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	return len(fake.allocationsArgsForCall)
}

func (fake *FakeJobClient) AllocationsCalls(stub func(string, bool, *api.QueryOptions) ([]*api.AllocationListStub, *api.QueryMeta, error)) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = stub
}

func (fake *FakeJobClient) AllocationsArgsForCall(i int) (string, bool, *api.QueryOptions) {
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	argsForCall := fake.allocationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeJobClient) AllocationsReturns(result1 []*api.AllocationListStub, result2 *api.QueryMeta, result3 error) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = nil
	fake.allocationsReturns = struct {
		result1 []*api.AllocationListStub
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) AllocationsReturnsOnCall(i int, result1 []*api.AllocationListStub, result2 *api.QueryMeta, result3 error) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = nil
	if fake.allocationsReturnsOnCall == nil {
		fake.allocationsReturnsOnCall = make(map[int]struct {
			result1 []*api.AllocationListStub
			result2 *api.QueryMeta
			result3 error
		})
	}
	fake.allocationsReturnsOnCall[i] = struct {
		result1 []*api.AllocationListStub
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) Deregister(arg1 string, arg2 bool, arg3 *api.WriteOptions) (string, *api.WriteMeta, error) {
	fake.deregisterMutex.Lock()
	ret, specificReturn := fake.deregisterReturnsOnCall[len(fake.deregisterArgsForCall)]
	fake.deregisterArgsForCall = append(fake.deregisterArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 *api.WriteOptions
	}{arg1, arg2, arg3})
	stub := fake.DeregisterStub
	fakeReturns := fake.deregisterReturns
	fake.recordInvocation("Deregister", []interface{}{arg1, arg2, arg3})
	fake.deregisterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJobClient) DeregisterCallCount() int {
	fake.deregisterMutex.RLock()
	defer fake.deregisterMutex.RUnlock()
	return len(fake.deregisterArgsForCall)
}

func (fake *FakeJobClient) DeregisterCalls(stub func(string, bool, *api.WriteOptions) (string, *api.WriteMeta, error)) {
	fake.deregisterMutex.Lock()
	defer fake.deregisterMutex.Unlock()
	fake.DeregisterStub = stub
}

func (fake *FakeJobClient) DeregisterArgsForCall(i int) (string, bool, *api.WriteOptions) {
	fake.deregisterMutex.RLock()
	defer fake.deregisterMutex.RUnlock()
	argsForCall := fake.deregisterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeJobClient) DeregisterReturns(result1 string, result2 *api.WriteMeta, result3 error) {
	fake.deregisterMutex.Lock()
	defer fake.deregisterMutex.Unlock()
	fake.DeregisterStub = nil
	fake.deregisterReturns = struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) DeregisterReturnsOnCall(i int, result1 string, result2 *api.WriteMeta, result3 error) {
	fake.deregisterMutex.Lock()
	defer fake.deregisterMutex.Unlock()
	fake.DeregisterStub = nil
	if fake.deregisterReturnsOnCall == nil {
		fake.deregisterReturnsOnCall = make(map[int]struct {
			result1 string
			result2 *api.WriteMeta
			result3 error
		})
	}
	fake.deregisterReturnsOnCall[i] = struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) Info(arg1 string, arg2 *api.QueryOptions) (*api.Job, *api.QueryMeta, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 string
		arg2 *api.QueryOptions
	}{arg1, arg2})
	stub := fake.InfoStub
	fakeReturns := fake.infoReturns
	fake.recordInvocation("Info", []interface{}{arg1, arg2})
	fake.infoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJobClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeJobClient) InfoCalls(stub func(string, *api.QueryOptions) (*api.Job, *api.QueryMeta, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeJobClient) InfoArgsForCall(i int) (string, *api.QueryOptions) {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJobClient) InfoReturns(result1 *api.Job, result2 *api.QueryMeta, result3 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 *api.Job
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) InfoReturnsOnCall(i int, result1 *api.Job, result2 *api.QueryMeta, result3 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 *api.Job
			result2 *api.QueryMeta
			result3 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 *api.Job
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) List(arg1 *api.QueryOptions) ([]*api.JobListStub, *api.QueryMeta, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 *api.QueryOptions
	}{arg1})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJobClient) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeJobClient) ListCalls(stub func(*api.QueryOptions) ([]*api.JobListStub, *api.QueryMeta, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeJobClient) ListArgsForCall(i int) *api.QueryOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJobClient) ListReturns(result1 []*api.JobListStub, result2 *api.QueryMeta, result3 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []*api.JobListStub
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) ListReturnsOnCall(i int, result1 []*api.JobListStub, result2 *api.QueryMeta, result3 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []*api.JobListStub
			result2 *api.QueryMeta
			result3 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []*api.JobListStub
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) Register(arg1 *api.Job, arg2 *api.WriteOptions) (*api.JobRegisterResponse, *api.WriteMeta, error) {
	fake.registerMutex.Lock()
	ret, specificReturn := fake.registerReturnsOnCall[len(fake.registerArgsForCall)]
	fake.registerArgsForCall = append(fake.registerArgsForCall, struct {
		arg1 *api.Job
		arg2 *api.WriteOptions
	}{arg1, arg2})
	stub := fake.RegisterStub
	fakeReturns := fake.registerReturns
	fake.recordInvocation("Register", []interface{}{arg1, arg2})
	fake.registerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJobClient) RegisterCallCount() int {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	return len(fake.registerArgsForCall)
}

func (fake *FakeJobClient) RegisterCalls(stub func(*api.Job, *api.WriteOptions) (*api.JobRegisterResponse, *api.WriteMeta, error)) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = stub
}

func (fake *FakeJobClient) RegisterArgsForCall(i int) (*api.Job, *api.WriteOptions) {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	argsForCall := fake.registerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJobClient) RegisterReturns(result1 *api.JobRegisterResponse, result2 *api.WriteMeta, result3 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	fake.registerReturns = struct {
		result1 *api.JobRegisterResponse
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) RegisterReturnsOnCall(i int, result1 *api.JobRegisterResponse, result2 *api.WriteMeta, result3 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	if fake.registerReturnsOnCall == nil {
		fake.registerReturnsOnCall = make(map[int]struct {
			result1 *api.JobRegisterResponse
			result2 *api.WriteMeta
			result3 error
		})
	}
	fake.registerReturnsOnCall[i] = struct {
		result1 *api.JobRegisterResponse
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) Summary(arg1 string, arg2 *api.QueryOptions) (*api.JobSummary, *api.QueryMeta, error) {
	fake.summaryMutex.Lock()
	ret, specificReturn := fake.summaryReturnsOnCall[len(fake.summaryArgsForCall)]
	fake.summaryArgsForCall = append(fake.summaryArgsForCall, struct {
		arg1 string
		arg2 *api.QueryOptions
	}{arg1, arg2})
	stub := fake.SummaryStub
	fakeReturns := fake.summaryReturns
	fake.recordInvocation("Summary", []interface{}{arg1, arg2})
	fake.summaryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJobClient) SummaryCallCount() int {
	fake.summaryMutex.RLock()
	defer fake.summaryMutex.RUnlock()
	return len(fake.summaryArgsForCall)
}

func (fake *FakeJobClient) SummaryCalls(stub func(string, *api.QueryOptions) (*api.JobSummary, *api.QueryMeta, error)) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = stub
}

func (fake *FakeJobClient) SummaryArgsForCall(i int) (string, *api.QueryOptions) {
	fake.summaryMutex.RLock()
	defer fake.summaryMutex.RUnlock()
	argsForCall := fake.summaryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJobClient) SummaryReturns(result1 *api.JobSummary, result2 *api.QueryMeta, result3 error) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = nil
	fake.summaryReturns = struct {
		result1 *api.JobSummary
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) SummaryReturnsOnCall(i int, result1 *api.JobSummary, result2 *api.QueryMeta, result3 error) {
	fake.summaryMutex.Lock()
	defer fake.summaryMutex.Unlock()
	fake.SummaryStub = nil
	if fake.summaryReturnsOnCall == nil {
		fake.summaryReturnsOnCall = make(map[int]struct {
			result1 *api.JobSummary
			result2 *api.QueryMeta
			result3 error
		})
	}
	fake.summaryReturnsOnCall[i] = struct {
		result1 *api.JobSummary
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	fake.deregisterMutex.RLock()
	defer fake.deregisterMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	fake.summaryMutex.RLock()
	defer fake.summaryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeJobClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ nomad.JobClient = new(FakeJobClient)
